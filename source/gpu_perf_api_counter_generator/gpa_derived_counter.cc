//==============================================================================
// Copyright (c) 2016-2025 Advanced Micro Devices, Inc. All rights reserved.
/// @author AMD Developer Tools Team
/// @file
/// @brief Manages a set of derived counters.
//==============================================================================

#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdint>
#include <sstream>

#include "gpu_perf_api_common/gpa_common_defs.h"
#include "gpu_perf_api_common/logging.h"
#include "gpu_perf_api_common/utility.h"
#include "gpu_perf_api_common/gpa_array_view.hpp"

#include "gpu_perf_api_counter_generator/gpa_derived_counter.h"
#include "gpu_perf_api_counter_generator/gpa_derived_counter_evaluator.hpp"
#include "gpu_perf_api_counter_generator/gpa_hardware_counters.h"

GpaDerivedCounterInfoClass::GpaDerivedCounterInfoClass(unsigned int              index,
                                                       const char*               counter_name,
                                                       const char*               counter_group,
                                                       const char*               counter_description,
                                                       GpaDataType               data_type,
                                                       GpaUsageType              usage_type,
                                                       bool                      discrete_counter,
                                                       bool                      spm_counter,
                                                       gpa_array_view<GpaUInt32> internal_counters_required,
                                                       const char*               compute_expression,
                                                       const char*               uuid)
    : counter_index_(index)
    , counter_name_(counter_name)
    , counter_group_(counter_group)
    , counter_description_(counter_description)
    , data_type_(data_type)
    , usage_type_(usage_type)
    , discrete_counter_(discrete_counter)
    , spm_counter_(spm_counter)
    , internal_counters_required_(internal_counters_required)
    , compute_expression_(compute_expression)
{
    uint32_t bytes[8];
#ifdef _WIN32
    sscanf_s(uuid,
             "%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X",
             &uuid_.Data1,
             &uuid_.Data2,
             &uuid_.Data3,
             &bytes[0],
             &bytes[1],
             &bytes[2],
             &bytes[3],
             &bytes[4],
             &bytes[5],
             &bytes[6],
             &bytes[7]);

    for (int i = 0; i < _countof(bytes); ++i)
    {
        uuid_.Data4[i] = static_cast<unsigned char>(bytes[i]);
    }

#else
    // Autogenerated hash is MD5 hash which are fixed length of 128-bits (16 bytes).
    uint32_t data1;
    static_assert(sizeof(short) == sizeof(uint16_t), "short is more than 2 bytes for UUID");
    sscanf(uuid,
           "%08uiX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X",
           &data1,
           &uuid_.data_2,
           &uuid_.data_3,
           &bytes[0],
           &bytes[1],
           &bytes[2],
           &bytes[3],
           &bytes[4],
           &bytes[5],
           &bytes[6],
           &bytes[7]);

    // data_1 of GpaUuid is a 'long' type which is 8 bytes on GCC/clang on Linux
    // We need to copy 4 bytes of data1 to data_1 until we update the GpaUuid structure
    // to match with standard MD5 struct. This change will be non-backward compatible
    // change due to difference in ABI. It should be changed in GPA 4.0.
    memset(&uuid_.data_1, 0, sizeof(uuid_.data_1));
    memcpy(&uuid_.data_1, &data1, sizeof(uint32_t));

    for (size_t i = 0; i < (sizeof(bytes) / sizeof(bytes[0])); ++i)
    {
        uuid_.data_4[i] = static_cast<unsigned char>(bytes[i]);
    }

#endif
}

GpaDerivedCounterInfoClass::~GpaDerivedCounterInfoClass()
{
    if (nullptr != counter_info_)
    {
        delete counter_info_->gpa_derived_counter;
    }

    delete counter_info_;
}

bool GpaDerivedCounterInfoClass::InitializeDerivedCounterHardwareInfo(const IGpaCounterAccessor* gpa_counter_accessor)
{
    bool counter_init = false;
    if (nullptr != counter_info_)
    {
        if (nullptr != counter_info_->gpa_derived_counter)
        {
            // The derived counter has already been initialized, return true.
            counter_init = true;
        }
        else
        {
            counter_info_->gpa_derived_counter = new (std::nothrow) GpaDerivedCounterInfo();

            if (nullptr != counter_info_->gpa_derived_counter)
            {
                const GpaHardwareCounters& hardware_counters = gpa_counter_accessor->GetHardwareCounters();

                for (const GpaUInt32 internal_counter : internal_counters_required_)
                {
                    GpaHwCounter hw_counter;
                    if (hardware_counters.GetHardwareInfo(internal_counter, hw_counter))
                    {
                        hw_counter_info_list_.push_back(hw_counter);
                    }
                }

                if (!hw_counter_info_list_.empty())
                {
                    assert(internal_counters_required_.size() == hw_counter_info_list_.size());
                    counter_info_->is_derived_counter                        = true;
                    counter_info_->gpa_derived_counter->gpa_hw_counter_count = static_cast<GpaUInt32>(internal_counters_required_.size());
                    counter_info_->gpa_derived_counter->counter_usage_type   = usage_type_;
                    counter_info_->gpa_derived_counter->gpa_hw_counters      = hw_counter_info_list_.data();
                    counter_init                                             = true;
                }
            }
        }
    }

    return counter_init;
}

GpaCounterInfo* GpaDerivedCounterInfoClass::GetCounterInfo(const IGpaCounterAccessor* gpa_counter_accessor)
{
    if (nullptr == counter_info_)
    {
        counter_info_ = new (std::nothrow) GpaCounterInfo();

        if (nullptr != counter_info_ && InitializeDerivedCounterHardwareInfo(gpa_counter_accessor))
        {
            derived_counter_info_init_ = true;
        }
    }

    if (derived_counter_info_init_)
    {
        return counter_info_;
    }

    return nullptr;
}

void GpaDerivedCounters::DefineDerivedCounter(const char*               counter_name,
                                              const char*               counter_group,
                                              const char*               counter_description,
                                              GpaDataType               data_type,
                                              GpaUsageType              usage_type,
                                              bool                      discrete_counter,
                                              bool                      spm_counter,
                                              gpa_array_view<GpaUInt32> internal_counters_required,
                                              const char*               compute_expression,
                                              const char*               uuid)
{
    assert(counter_name);
    assert(counter_group);
    assert(counter_description);
    assert(data_type < kGpaDataTypeLast);
    assert(!internal_counters_required.empty());
    assert(compute_expression);
    assert(strlen(compute_expression) > 0);
    assert(uuid);

    const auto index = static_cast<unsigned int>(derived_counter_list_.size());

#ifdef ANDROID
    if ((strcmp(counter_name, "LocalVidMemBytes") == 0) || (strcmp(counter_name, "PcieBytes") == 0))
    {
        return;
    }
#endif

    const bool add_counter = ((kGpaSessionSampleTypeDiscreteCounter == sample_type_) && discrete_counter) ||
                             ((kGpaSessionSampleTypeStreamingCounter == sample_type_) && spm_counter);

    if (add_counter)
    {
        derived_counter_list_.emplace_back(GpaDerivedCounterInfoClass(index,
                                                                      counter_name,
                                                                      counter_group,
                                                                      counter_description,
                                                                      data_type,
                                                                      usage_type,
                                                                      discrete_counter,
                                                                      spm_counter,
                                                                      internal_counters_required,
                                                                      compute_expression,
                                                                      uuid));
    }
}

void GpaDerivedCounters::UpdateAsicSpecificDerivedCounter(const char*               counter_name,
                                                          gpa_array_view<GpaUInt32> internal_counters_required,
                                                          const char*               compute_expression)
{
    for (auto& counter : derived_counter_list_)
    {
        if (!_strcmpi(counter_name, counter.counter_name_))
        {
            counter.internal_counters_required_ = internal_counters_required;
            counter.compute_expression_         = compute_expression;
            return;
        }
    }

    // Errors aside, the counter will not be found if it's not supported on the ASIC.
    // e.g.: there's a discrete counter version, but not an SPM version.
    {
        GPA_LOG_MESSAGE("Warning: unable to find counter for ASIC-specific update:%s . This may be an unsupported SPM counter.", counter_name);
    }
}

void GpaDerivedCounters::Clear()
{
    derived_counter_list_.clear();
    counters_generated_ = false;
}

GpaUInt32 GpaDerivedCounters::GetNumCounters() const
{
    return static_cast<GpaUInt32>(derived_counter_list_.size());
}

GpaStatus GpaDerivedCounters::ComputeCounterValue(GpaUInt32                       counter_index,
                                                  const gpa_array_view<GpaUInt64> results,
                                                  void*                           result,
                                                  const GpaHwInfo&                hw_info) const
{
    const char* compute_expression = derived_counter_list_[counter_index].compute_expression_;
    if (nullptr == compute_expression)
    {
        GPA_LOG_ERROR("Unable to compute counter value: no equation specified.");
        return kGpaStatusErrorInvalidCounterEquation;
    }

    GpaStatus status = kGpaStatusOk;

    const GpaDataType date_type = derived_counter_list_[counter_index].data_type_;

    static_assert(kGpaDataTypeLast == 2);

    if (date_type == kGpaDataTypeFloat64)
    {
        status = EvaluateExpression<GpaFloat64>(compute_expression, result, results, date_type, hw_info);

    }
    else if (date_type == kGpaDataTypeUint64)
    {
        status = EvaluateExpression<GpaUInt64>(compute_expression, result, results, date_type, hw_info);

    }
    else
    {
        // Derived counter type not recognized or not currently supported.
        GPA_LOG_ERROR("Unable to compute counter value: unrecognized derived counter type.");
        assert(false);
        return kGpaStatusErrorInvalidDataType;
    }

    return status;
}
