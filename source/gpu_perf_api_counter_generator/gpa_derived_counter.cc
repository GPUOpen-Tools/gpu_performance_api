//==============================================================================
// Copyright (c) 2016-2021 Advanced Micro Devices, Inc. All rights reserved.
/// @author AMD Developer Tools Team
/// @file
/// @brief Manages a set of derived counters.
//==============================================================================

#include <stdio.h>
#include <string.h>  // For strcpy.

#ifdef __cplusplus
#include <cstdint>
#else
#include <stdint.h>
#endif

#include <algorithm>
#include <sstream>

#include "gpu_perf_api_common/gpa_common_defs.h"
#include "gpu_perf_api_common/logging.h"
#include "gpu_perf_api_common/utility.h"

#include "gpu_perf_api_counter_generator/gpa_derived_counter.h"
#include "gpu_perf_api_counter_generator/gpa_hardware_counters.h"

GpaDerivedCounterInfoClass::GpaDerivedCounterInfoClass()
    : counter_index_(0u)
    , counter_name_(nullptr)
    , counter_group_(nullptr)
    , counter_description_(nullptr)
    , data_type_(kGpaDataTypeLast)
    , usage_type_(kGpaUsageTypeLast)
    , compute_expression_(nullptr)
    , counter_info_(nullptr)
    , derived_counter_info_init_(false)
{
}

GpaDerivedCounterInfoClass::GpaDerivedCounterInfoClass(unsigned int       index,
                                                       const char*        counter_name,
                                                       const char*        counter_group,
                                                       const char*        counter_description,
                                                       GpaDataType        data_type,
                                                       GpaUsageType       usage_type,
                                                       vector<GpaUInt32>& internal_counters_required,
                                                       const char*        compute_expression,
                                                       const char*        uuid)
    : counter_index_(index)
    , counter_name_(counter_name)
    , counter_group_(counter_group)
    , counter_description_(counter_description)
    , data_type_(data_type)
    , usage_type_(usage_type)
    , internal_counters_required_(internal_counters_required)
    , compute_expression_(compute_expression)
    , counter_info_(nullptr)
    , derived_counter_info_init_(false)
{
    uint32_t bytes[8];
#ifdef _WIN32
    sscanf_s(uuid,
             "%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X",
             &uuid_.Data1,
             &uuid_.Data2,
             &uuid_.Data3,
             &bytes[0],
             &bytes[1],
             &bytes[2],
             &bytes[3],
             &bytes[4],
             &bytes[5],
             &bytes[6],
             &bytes[7]);

    for (int i = 0; i < _countof(bytes); ++i)
    {
        uuid_.Data4[i] = static_cast<unsigned char>(bytes[i]);
    }

#else
    // Autogenerated hash is MD5 hash which are fixed length of 128-bits (16 bytes).
    uint32_t data1;
    static_assert(sizeof(short) == sizeof(uint16_t), "short is more than 2 bytes for UUID");
    sscanf(uuid,
           "%08uiX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X",
           &data1,
           &uuid_.data_2,
           &uuid_.data_3,
           &bytes[0],
           &bytes[1],
           &bytes[2],
           &bytes[3],
           &bytes[4],
           &bytes[5],
           &bytes[6],
           &bytes[7]);

    // data_1 of GpaUuid is a 'long' type which is 8 bytes on GCC/clang on Linux
    // We need to copy 4 bytes of data1 to data_1 until we update the GpaUuid structure
    // to match with standard MD5 struct. This change will be non-backward compatible
    // change due to difference in ABI. It should be changed in GPA 4.0.
    memset(&uuid_.data_1, 0, sizeof(uuid_.data_1));
    memcpy(&uuid_.data_1, &data1, sizeof(uint32_t));

    for (size_t i = 0; i < (sizeof(bytes) / sizeof(bytes[0])); ++i)
    {
        uuid_.data_4[i] = static_cast<unsigned char>(bytes[i]);
    }

#endif
}

GpaDerivedCounterInfoClass::~GpaDerivedCounterInfoClass()
{
    if (nullptr != counter_info_)
    {
        delete counter_info_->gpa_derived_counter;
    }

    delete counter_info_;
}

bool GpaDerivedCounterInfoClass::InitializeDerivedCounterHardwareInfo(const IGpaCounterAccessor* gpa_counter_accessor)
{
    bool counter_init = false;
    if (nullptr != counter_info_)
    {
        if (nullptr != counter_info_->gpa_derived_counter)
        {
            // The derived counter has already been initialized, return true.
            counter_init = true;
        }
        else
        {
            counter_info_->gpa_derived_counter = new (std::nothrow) GpaDerivedCounterInfo();

            if (nullptr != counter_info_->gpa_derived_counter)
            {
                const GpaHardwareCounters* hardware_counters = gpa_counter_accessor->GetHardwareCounters();

                for (auto iter = internal_counters_required_.cbegin(); iter != internal_counters_required_.cend(); ++iter)
                {
                    GpaHwCounter hw_counter;

                    if (hardware_counters->GetHardwareInfo(*iter, hw_counter))
                    {
                        hw_counter_info_list_.push_back(hw_counter);
                    }
                }

                if (!hw_counter_info_list_.empty())
                {
                    assert(internal_counters_required_.size() == hw_counter_info_list_.size());
                    counter_info_->is_derived_counter                        = true;
                    counter_info_->gpa_derived_counter->gpa_hw_counter_count = static_cast<GpaUInt32>(internal_counters_required_.size());
                    counter_info_->gpa_derived_counter->counter_usage_type   = usage_type_;
                    counter_info_->gpa_derived_counter->gpa_hw_counters      = hw_counter_info_list_.data();
                    counter_init                                             = true;
                }
            }
        }
    }

    return counter_init;
}

GpaCounterInfo* GpaDerivedCounterInfoClass::GetCounterInfo(const IGpaCounterAccessor* gpa_counter_accessor)
{
    if (nullptr == counter_info_)
    {
        counter_info_ = new (std::nothrow) GpaCounterInfo();

        if (nullptr != counter_info_ && InitializeDerivedCounterHardwareInfo(gpa_counter_accessor))
        {
            derived_counter_info_init_ = true;
        }
    }

    if (derived_counter_info_init_)
    {
        return counter_info_;
    }

    return nullptr;
}

void GpaDerivedCounters::DefineDerivedCounter(const char*         counter_name,
                                              const char*         counter_group,
                                              const char*         counter_description,
                                              GpaDataType         data_type,
                                              GpaUsageType        usage_type,
                                              vector<GpaUInt32>&  internal_counters_required,
                                              const char*         compute_expression,
                                              const char*         uuid)
{
    assert(counter_name);
    assert(counter_group);
    assert(counter_description);
    assert(data_type < kGpaDataTypeLast);
    assert(!internal_counters_required.empty());
    assert(compute_expression);
    assert(strlen(compute_expression) > 0);
    assert(uuid);

    unsigned int index = static_cast<unsigned int>(derived_counter_list_.size());

#ifdef ANDROID
    if ((strcmp(counter_name, "LocalVidMemBytes") == 0) || (strcmp(counter_name, "PcieBytes") == 0))
    {
        return;
    }
#endif

    derived_counter_list_.push_back(
        GpaDerivedCounterInfoClass(index, counter_name, counter_group, counter_description, data_type, usage_type, internal_counters_required, compute_expression, uuid));
}

void GpaDerivedCounters::UpdateAsicSpecificDerivedCounter(const char* counter_name, vector<GpaUInt32>& internal_counters_required, const char* compute_expression)
{
    for (auto& counter : derived_counter_list_)
    {
        if (!_strcmpi(counter_name, counter.counter_name_))
        {
            counter.internal_counters_required_.clear();
            counter.internal_counters_required_ = internal_counters_required;
            counter.compute_expression_       = compute_expression;
            return;
        }
    }

    // Errors aside, the counter will not be found if it's not supported on the ASIC.
    // e.g.: there's a discrete counter version, but not an SPM version.
    {
        std::stringstream o;
        o << "Warning: unable to find counter for ASIC-specific update:" << counter_name << ". This may be an unsupported SPM counter.";
        GPA_LOG_MESSAGE(o.str().c_str());
    }
}

void GpaDerivedCounters::Clear()
{
    derived_counter_list_.clear();
    counters_generated_ = false;
}

GpaUInt32 GpaDerivedCounters::GetNumCounters() const
{
    return static_cast<GpaUInt32>(derived_counter_list_.size());
}

#include "gpu_perf_api_counter_generator/gpa_derived_counter_evaluator.inc"

GpaStatus GpaDerivedCounters::ComputeCounterValue(GpaUInt32                       counter_index,
                                                  const vector<const GpaUInt64*>& results,
                                                  vector<GpaDataType>&            internal_counter_types,
                                                  void*                           result,
                                                  const GpaHwInfo*                hw_info) const
{
    if (nullptr == derived_counter_list_[counter_index].compute_expression_)
    {
        GPA_LOG_ERROR("Unable to compute counter value: no equation specified.");
        return kGpaStatusErrorInvalidCounterEquation;
    }

#ifdef AMDT_INTERNAL
    GPA_LOG_DEBUG_COUNTER_DEFS(
        "'%s' equation is %s.", derived_counter_list_[counter_index].counter_name_, derived_counter_list_[counter_index].compute_expression_);
#endif

    GpaStatus status = kGpaStatusOk;

    if (internal_counter_types[0] == kGpaDataTypeUint64)
    {
        if (derived_counter_list_[counter_index].data_type_ == kGpaDataTypeFloat64)
        {
            status = EvaluateExpression<GpaFloat64, GpaUInt64>(
                derived_counter_list_[counter_index].compute_expression_, result, results, derived_counter_list_[counter_index].data_type_, hw_info);
        }
        else if (derived_counter_list_[counter_index].data_type_ == kGpaDataTypeUint64)
        {
            status = EvaluateExpression<GpaUInt64, GpaUInt64>(
                derived_counter_list_[counter_index].compute_expression_, result, results, derived_counter_list_[counter_index].data_type_, hw_info);
        }
        else
        {
            // Derived counter type not recognized or not currently supported.
            GPA_LOG_ERROR("Unable to compute counter value: unrecognized derived counter type.");
            assert(false);
        }
    }
    else
    {
        GPA_LOG_ERROR("Unable to compute counter value: unrecognized derived counter type.");
        return kGpaStatusErrorInvalidDataType;
    }

    return status;
}
